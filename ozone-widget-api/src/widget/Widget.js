/**
 * @ignore
 */
var Ozone = Ozone ? Ozone : {};

/**
 * @namespace
 * @since OWF 5.0
 */
OWF = window.OWF ? window.OWF : {};

(function(window, document, undefined) {

	var WIDGET_READY_SERVICE_NAME = '_widgetReady',
		DASHBOARD_GET_PANES_SERVICE_NAME = '_DASHBOARD_GET_PANES',

        isReady = false,
		readyList = [],
		widget = Ozone.util.parseWindowNameData(),
		eventingController,
		dragAndDropController,
		launchingController,
		chromeController;

	owfdojo.mixin(OWF, /** @lends OWF */ {

		/**
		 * The OWF.Eventing object manages the eventing for an individual widget
		 *
		 * @namespace
		 * @name OWF.Eventing
		 */
		Eventing: {},

		/**
		 * @namespace
		 * @name OWF.RPC
		 */
		RPC: {},

		/**
		 * This object is used to create, retrieve, update and delete user preferences.
		 *
		 * @namespace
		 * @name OWF.Preferences
		 */
		Preferences: {},

		/**
		 * This object is used launch other widgets.
		 *
		 * @namespace
		 * @name OWF.Launcher
		 */
		Launcher: {},

		/**
		 * The OWF.DragAndDrop object manages the drag and drop for an individual widget.
		 *
		 * @namespace
		 * @name OWF.DragAndDrop
		 */
		DragAndDrop: {},

		/**
		 * This object allows a widget to modify the button contained in the widget header (the chrome).
		 *
		 * @namespace
		 * @name OWF.Chrome
		 */
		Chrome: {},

		/**
		 * Provides OWF utility methods for the widget developer
		 *
		 * @namespace
		 * @name OWF.Util
		 */
		Util: Ozone.util,

		/**
		 *
		 *
		 * @namespace
		 * @name OWF.Metrics
		 */
		Metrics: Ozone.metrics,

		/**
		 * Provides functions to log messages and objects
		 *
		 * @namespace
		 * @name OWF.Log
		 */
		Log: Ozone.log,

		/**
		 * Provides utility methods for localization
		 *
		 * @namespace
		 * @name OWF.Lang
		 */
		Lang: Ozone.lang,

		/**
		 *
		 *
		 * @namespace
		 * @name OWF.Audit
		 */
		Audit: Ozone.audit,

		Version: Ozone.version,

		/**
			Accepts a function that is executed when Ozone APIs are ready for use
			@param {Function} handler Function to execute when OWF APIs are ready
			@param {Object} scope The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.
		*/
		ready: function(handler, scope) {

			if(handler === undefined) {
				throw 'Error: no arguments passed';
				return;
			}

			if(typeof handler !== 'function') {
				throw 'Error: handler must be a function';
				return;
			}

			isReady === true ? handler.call(scope) : readyList.push( {fn: handler, scope: scope} );

		},

      /**
       * This function should be called once the widget is ready and all initialization is completed.  This will send a
       * message to the container which in turn may notify other widgets
       */
        notifyWidgetReady: function() {
          //send a message to container that this widget is ready
          gadgets.rpc.call('..', WIDGET_READY_SERVICE_NAME, null, OWF.getInstanceId());
        },

		/**
			Returns definition GUID of the widget. This is auto generated by OWF when the widget was brought in an OWF instance.
		*/
		getWidgetGuid : function() {
			return widget.guid;
		},

		/**
			Returns instance GUID of the widget.
		*/
		getInstanceId : function() {
			return widget.id;
		},

        /**
         * @description Returns the Widget Id
         * @returns {String} The widgetId is a complex JSON encoded string which identifies a widget for Eventing.
         *   Embedded in this string is the widget's uniqueId as the 'id' attribute.  There is other data is in the string
         *   which is needed for Eventing and other APIs to function properly. This complex widgetId string may be used in
         *   the <a href="./OWF.Eventing.html#.publish">OWF.Eventing.publish</a> function to designate a specific recipient for a message.
         *   Additionally, once subscribed to a channel via <a href="./OWF.Eventing.html#.subscribe">OWF.Eventing.subscribe</a> during the
         *   receipt of a message, the sender's widgetId is made available as the first argument to the handler function.
         * @example
         * //decode and retrieve the widget's unique id
         * var complexIdString = OWF.getIframeId();
         * var complexIdObj = owfdojo.toJson(complexIdString);
         *
         * //complexIdObj will look like
         * // {
         * //  //widget's uniqueId
         * //  id:"49cd21f0-3110-8121-d905-18ffa81b442e"
         * // }
         *
         * //get Widget's uniqueId
         * alert('widget id = ' + complexIdObj.id);
         */
		getIframeId : function() {
			return '{\"id\":\"' + widget.id + '\"}';
		},

		/**
			Returns type of dashboard in which the widget is opened. [portal, desktop, accordion, tabbed]
		*/
		getDashboardLayout : function() {
			return widget.layout;
		},

		/**
			Returns version of the widget.
		*/
		getVersion : function() {
			return widget.version;
		},

		/**
			Returns URL of the widget.
		*/
		getUrl : function() {
			return widget.url;
		},

		/**
			Returns an object containing information on the current OWF theme
			@returns {Object} Returns an object below: <br>
			{ <br>
				//name of the theme <br>
				themeName: 'theme-name', <br>
				<br>
				//describes color contrast of the theme.  This may be one of 3 values: <br>
				// 'standard' (colors provide no special contrast) <br>
				// 'black-on-white' (black on white color contrast) <br>
				// 'white-on-black' (white on black color contrast) <br>
				themeContrast: 'black-on-white', <br>
				<br>
				//this field is a number of the fontSize in pixels <br>
				themeFontSize: 12 <br>
			}
			@example
			var themeObj = OWF.getCurrentTheme();
		*/
		getCurrentTheme : function() {
			return widget.currentTheme;
		},

		/**
			Returns the name of the Container the Widget is in
		*/
		getContainerName: function() {
			return widget.containerName;
		},

		/**
			Returns the version of the Container the Widget is in
		*/
		getContainerVersion: function() {
			return widget.containerVersion;
		},

		/**
			Returns whether or not the dashboard in which the widget is opened is locked.
		*/
		isDashboardLocked : function() {
			return widget.locked;
		},

		/**
		Returns the URL of the Container the Widget is in
		*/
		getContainerUrl: function() {
            //figure out from preference location
			var pref = widget.preferenceLocation;
            return pref.substring(0, pref.length - 6);
		},

		/**
			Gets all opened widgets on the current dashboard.

			@param {Function} callback function to execute when opened widgets are retrieved from OWF. Function is passed an array of objects with the structure below: <br>
			{<br>
				id: 'instance guid of widget',<br>
				frameId: 'iframe id of widget',<br>
				widgetGuid: 'widget guid of the widget',<br>
				url: 'url of the widget',<br>
				name: 'name of the widget'<br>
                universalName: 'universal name of the widget'<br>
			}<br>
			@example
			OWF.getOpenedWidgets(function(openedWidgets) {

			});
		*/
		getOpenedWidgets: function(fn) {

			if(fn === undefined) {
				throw 'Error: no arguments passed';
				return;
			}

			if(typeof fn !== 'function') {
				throw 'Error: fn must be a function';
				return;
			}

			Ozone.eventing.getAllWidgets(fn);
		},

		/**
			Gets all layout panes on the current dashboard. Useful for launching widgets in other panes.

			@param {Function} callback function to execute when layout panes are retrieved from OWF. Function is passed an array of objects with the structure below: <br>
			{<br>
				id: 'pane guid',<br>
				type: 'fitpane', // fitpane, desktoppane, accordionpane, fitpane or portalpane <br>
				height: 398,<br>
				width: 715,<br>
				x: 0,<br>
				y: 33,<br>
				widgets: [{widget state object}]'<br>
			}<br>
			@see <a href="#WidgetState.getState">widget state</a>
			@example
			OWF.getPanes(function(panes) {
				...
			});
		*/
		getPanes: function(fn) {
			if(fn === undefined) {
				throw 'Error: no arguments passed';
				return;
			}

			if(typeof fn !== 'function') {
				throw 'Error: fn must be a function';
				return;
			}

            gadgets.rpc.call('..', DASHBOARD_GET_PANES_SERVICE_NAME, fn, OWF.getIframeId());
		}

	});

	// for backwards compatibility
	Ozone.Widget = OWF;

	OWF._init = function(window, document, undefined) {

        if (OWF.relayFile != null) {
          Ozone.eventing.Widget.widgetRelayURL = OWF.relayFile;
        }

		// Eventing API
		function initEventing() {
			for(var i = 0, methods = ['publish', 'subscribe', 'unsubscribe'] ; i < methods.length ; i++) {
				OWF.Eventing[ methods[i] ] = this[ methods[i] ];
			}
		}

		// RPC/Directed Eventing API
		function initRPC() {
			OWF.RPC.registerFunctions = Ozone.eventing.registerFunctions;

			OWF.RPC.getWidgetProxy = function(widgetId, ready, accessLevel) {
				Ozone.util.hasAccess( {
					widgetId: widgetId,
					accessLevel: accessLevel,
					senderId: OWF.getWidgetGuid(),
					callback: function(response) {
						if (response.hasAccess)
							return Ozone.eventing.importWidget(widgetId, ready)
					}
				});
			}


			OWF.RPC.handleDirectMessage = function(fn) {
				if(typeof fn !== 'function') {
					throw 'Error: fn must be a function';
					return;
				}
				Ozone.eventing.handleDirectMessage = fn;
			};
		}

		// Preferences API
		function initPreferences() {
			for(var i in Ozone.pref.PrefServer) {
				if(typeof Ozone.pref.PrefServer[ i ] === 'function')
					OWF.Preferences[ i ] = Ozone.pref.PrefServer[ i ];
			}
		}

		// Launching API
		function initLauncher() {
			OWF.Launcher.launch = launchingController.launchWidget;
			OWF.Launcher.getLaunchData = Ozone.launcher.WidgetLauncherUtils.getLaunchConfigData;
		}

		// Drag and Drop API
		function initDragAndDrop() {
			OWF.DragAndDrop = {
				onDragStart: function(callback, scope) {
					dragAndDropController.addCallback('dragStart', owfdojo.hitch(scope, callback));
					return this;
				},

				onDragStop: function(callback, scope) {
					dragAndDropController.addCallback('dragStop', owfdojo.hitch(scope, callback));
					return this;
				},

				onDrop: function(callback, scope) {
					dragAndDropController.addCallback('dropReceive', owfdojo.hitch(scope, callback));
					return this;
				},

				startDrag: function(cfg) {
					dragAndDropController.doStartDrag(cfg);
					return this;
				}
			};

			for(var i = 0, methods = ['addDropZoneHandler', 'getDragStartData', 'getDropEnabled', 'setDropEnabled', 'isDragging', 'getFlashWidgetId', 'setFlashWidgetId'] ; i < methods.length ; i++) {

				OWF.DragAndDrop[ methods[i] ] = function( methodName ) {

					return function() {
						return dragAndDropController[methodName].apply(dragAndDropController, arguments);
					};

				}( methods[i] );

			}
		}

		// Chrome API
		function initChrome() {
			for(var i = 0,
				methods = ['addHeaderButtons', 'addHeaderMenus', 'insertHeaderButtons', 'insertHeaderMenus',
                    'isModified', 'listHeaderButtons', 'listHeaderMenus', 'removeHeaderButtons', 'removeHeaderMenus',
                    'updateHeaderButtons', 'updateHeaderMenus', 'getTitle', 'setTitle'] ; i < methods.length ; i++) {
				OWF.Chrome[ methods[i] ] = chromeController[ methods[i] ];
			}
		}

		// Audit API
		function initAudit() {
			for(var i in Ozone.audit) {
				if(typeof Ozone.audit[ i ] === 'function')
					OWF.Audit[ i ] = Ozone.audit[ i ];
			}
		}

		eventingController = Ozone.eventing.Widget.getInstance(function() {

			dragAndDropController = Ozone.dragAndDrop.WidgetDragAndDrop.getInstance({
				widgetEventingController: this
			});
			launchingController = Ozone.launcher.WidgetLauncher.getInstance();
			chromeController = Ozone.chrome.WidgetChrome.getInstance({
				widgetEventingController: this
			});

			initEventing.call(this);
			initRPC();
			initPreferences();
			initLauncher();
			initDragAndDrop();
			initChrome();

			Ozone.components.keys.createKeyEventSender(this);

			// execute ready listeners
			isReady = true;
			for(var i = 0, len = readyList.length ; i < len ; i++) {
				readyList[i].fn.call(readyList[i].scope);
			}

		});

		Ozone.config = Ozone.config ? Ozone.config : {};
		Ozone.config.dataguard = Ozone.config.dataguard ? Ozone.config.dataguard : {};

		Ozone.util.Transport.send({
			url: OWF.getContainerUrl() + '/access/getConfig',
			method: 'GET',
			onSuccess: function(response) {
				Ozone.config.dataguard.allowMessagesWithoutAccessLevel = response.allowMessagesWithoutAccessLevel;
				Ozone.config.dataguard.auditAllMessages = response.auditAllMessages;
				Ozone.config.dataguard.restrictMessages = response.restrictMessages;
				Ozone.config.dataguard.accessLevelCacheTimeout = response.accessLevelCacheTimeout;
			}
		});

	};

}(window, document));

// --------------------------------------------------------------------------------------------------
// ------------------- Eventing ---------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------
/**
 * @name relayFile
 * @memberOf OWF
 * @description The location of the widget relay file.  The relay file should be defined
 *   globally for the entire widget by setting OWF.relayFile to the relay file url, immediately after
 *   including the widget bundle javascript.  If the relay is not defined at all it is assumed to be at
 *   /[context]/js/eventing/rpc_relay.uncompressed.html. The relay file must be specified with full location details, but without a fully
 *   qualified path. In the case where the relay is residing @ http://server/path/relay.html, the path used must be from the context root of the local
 *   widget. In this case, it would be /path/relay.html.  Do not include the protocol.
 * @since OWF 5.0.0
 * @example
 * &lt;script type="text/javascript" src="../../js-min/owf-widget-min.js"&gt;&lt;/script&gt;
 * &lt;script&gt;
 *       //The location is assumed to be at /[context]/js/eventing/rpc_relay.uncompressed.html if it is not
 *       //set the path correctly below
 *       OWF.relayFile = '/owf/js/eventing/rpc_relay.uncompressed.html';
 *       //...
 * &lt;/script&gt;
 *
 */

/**
	Subscribe to a named channel for a given function.
	@name subscribe
	@methodOf OWF.Eventing

	@param {String} channelName The channel to subscribe to.
	@param {Function} handler The function you wish to subscribe.  This function will be called with three
		arguments: sender, msg, channel.
	@param {String} [handler.sender] The first argument passed to the handler function is the id of the sender of the message. See <a href="OWF.html#.getIframeId">OWF.getIframeId</a> for a description of this id.
	@param {Object} [handler.msg] The second argument passed to the handler function is the message itself.
	@param {String} [handler.channel] The third argument passed to the handler function is the channel the message was published on.

	@example
OWF.Eventing.subscribe("ClockChannel", this.update);
var update = function(sender, msg, channel) {
	document.getElementById('currentTime').innerHTML = msg;
}
 */

/**
	Unsubscribe to a named channel.
	@name unsubscribe
	@methodOf OWF.Eventing

	@param {String} channelName The channel to unsubscribe to.

	@example
OWF.Eventing.unsubscribe("ClockChannel");
 */

/**
	Publishes a message to a given channel.
	@name publish
	@methodOf OWF.Eventing

	@param {String} channelName The name of the channel to publish to
	@param {Object} message The message to publish to the channel.
	@param {String} [dest] The id of a particular destination.  Defaults to null which sends to all
		subscribers on the channel.  See <a href="OWF.html#.getIframeId">OWF.getIframeId</a>
		for a description of the id.

	@example
OWF.Eventing.publish("ClockChannel", currentTimeString);
*/

// --------------------------------------------------------------------------------------------------
// ------------------- RPC --------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------

/**
	Register one or more functions to OWF to expose to other widgets.
	@name registerFunctions
	@methodOf OWF.RPC

	@param {Object/Array} objs Object or an array of objects of following structure.<br />
		{<br />
			name: 'name of the function', <br />
			fn: function() {}, <br />
			scope: window //The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.<br />
		}<br />

	@example
Calculator = {
	add: function() {
		var args = arguments,
			val = 0;
		for(var i = 0, len = args.length; i < len; i++) {
			val += parseFloat(args[i]);
		}
		return val;
	},
	multiply: function() {
		var args = arguments,
			val = 1;
		for(var i = 0, len = args.length; i < len; i++) {
			val *= parseFloat(args[i]);
		}
		return val;
	}
};
OWF.RPC.registerFunctions([
	{
		name: 'add'
		fn: Calculator.add,
		scope: Calculator
	},
	{
		name: 'multiply'
		fn: Calculator.multiply,
		scope: Calculator
	}
]);
*/

/**
	Gets a proxy object that contains methods exposed by other widget.
	@name getWidgetProxy
	@methodOf OWF.RPC

	@param {String} instanceGuid instance guid of the widget to import
	@param {Function} callback function that will be executed if the widget is found opened on the current dashboard. The function is passed a proxy object as the first argument which will contain methods that were exposed by the widget. In addition, the proxy abject also has sendMessage method to send a direct message to the widget.

	@example
OWF.RPC.getWidgetProxy('instanceGuid of widgetA', function(widgetA) {

	widgetA.add(1,2,3, function(result) {
		console.log(result); // log the result
	})

	widgetA.sendMessage('some secret message');

});
*/

/**
	Register a function to be executed when a direct message is received from another widget.
	@name handleDirectMessage
	@methodOf OWF.RPC

	@param {Function} fn function that will be executed when a direct message is received from another widget.

	@example
OWF.RPC.handleDirectMessage(function(msg) {
	// do something with the message
});
*/

// --------------------------------------------------------------------------------------------------
// ------------------- Drag and Drop ----------------------------------------------------------------
// --------------------------------------------------------------------------------------------------
/**
	Use this method to set flex dom element id, so that drag and drop can be enabled in flex widgets.
	@name setFlashWidgetId
	@methodOf OWF.DragAndDrop

	@param {String} id dom element id of flex widget
*/

/**
	Starts a drag.  The config object passed in describes the drag and contains the data to be passed to the drop.
	@name startDrag
	@methodOf OWF.DragAndDrop

	@param {Object} cfg config object see below
	@param {String} cfg.dragDropLabel Name to be used as text for the dragDrop indicator
	@param {Object} cfg.dragDropData Data to be sent on a successful drag and drop.  This property is only sent to the
	successful recipient of the drag (the dropReceive event).  It will not be sent for other events.
	@param {Object} cfg.dragZone dom node which presents a dragZone which is associated with this drag.  This property is
	only saved and used locally to the widget to identify whether a dragZone is in fact the node as a dropZone.  It will not be
	sent to other events callbacks.
	@param {Object} cfg.* other custom properties may be specified, these will be passed along to event handlers

	@example
//add handler to text field for dragging
owfdojo.connect(document.getElementById('dragSource'), 'onmousedown', this, function(e) {
	e.preventDefault();
	var data = document.getElementById('InputChannel').value;
	if (data) {
		OWF.DragAndDrop.startDrag({
			dragDropLabel: data,
			dragDropData: data,
			dragZone:  document.getElementById('dragZone'),
			dragDropGroup: 'location'  //extra property to pass along
		});
	}
});
*/


/**
	Adds a new drop zone to be managed.  The handler function defined in the cfg object will be called when
	a drop occurs over a dom node which matches the id or the className or is equal to or a child of the dropTarget node
	@name addDropZoneHandler
	@methodOf OWF.DragAndDrop

	@param {Object} cfg config object see below
	@param {className} cfg.class class of the dropZone
	@param {String} cfg.id Id of the dropZone
	@param {Node} cfg.dropZone HTML node which represents the dropZone
	@param {Function} cfg.handler function to be called when a drop occurs over the dropZone.  A msg object will be passed in

	@example
//Example cfg Object
{
	id: 'mygrid-1',
	className: 'mygridClass',
	dropZone: document.getElementById('dropZone'),
	handler: function(msg) {
		//some code here to handle the msg and respond
	}
}

//Example usage of addDropZoneHandler which handles a drop that occurs over an Ext Grid and inserts new data into
//that grid based on the dragged data
OWF.DragAndDrop.addDropZoneHandler({
	//dom node of an Ext grid
	dropZone:grid.getView().scroller.dom,

	//this function is called only when a drop occurs over the grid (i.e. the mouse was released over the grid)
	handler: (function(msg){

		var store = grid.getStore();
		var processedSelections = [];
		var errorMsg = null;

		//loop through msg.dragDropData which is an array and check for dupes versus the destination store
		for (var i = 0; i < msg.dragDropData.length; i++) {
			//get data for one possible new record in the dragDropData
			var recData = msg.dragDropData[i];

			//is it already in the dest Ext Store?
			if (store.findExact('id',recData.id) >= 0) {
				//found the record already in the store
			}
			else {
				//add new record based on the dragDropData
				var newRec = new store.recordType(recData);
				//calling an external function to decide whether to add the new rec
				var rs = displayPanel.validateRecordOnAdd(newRec);
				if (rs.success) {
					processedSelections.push(newRec);
				}
				else {
					errorMsg = rs.msg;
				}
			}
		}

		if (errorMsg) {
			Ext.Msg.alert('Error', errorMsg);
		}

		//actually insert into the store which adds it the new recs to the grid
		if (processedSelections.length > 0) {
			store.insert(0, processedSelections);
		}

}).createDelegate(grid)});   //createDelegate is an Ext function which sets the scope of the callback

*/


/**
	Returns whether the a drop is enabled (this is only true when the mouse is over a drop zone)
	@name getDropEnabled
	@methodOf OWF.DragAndDrop
*/

/**
	Returns whether a drag is in progress
	@name isDragging
	@methodOf OWF.DragAndDrop
*/

/**
	Returns data sent when a drag was started
	@name getDragStartData
	@methodOf OWF.DragAndDrop
*/

/**
	Toggles the dragIndicator to indicate successful or unsuccessful drop
	@name setDropEnabled
	@methodOf OWF.DragAndDrop

	@param {Boolean} dropEnabled true to enable a drop, false to indicate a unsuccessful drop

	@example
//attach mouseover callback to a particular area. If the mouse is here allow a drop
cmp.getView().scroller.on('mouseover',function(e,t,o) {
	if (cmp.dragging) {
		OWF.DragAndDrop.setDropEnabled(true);
	}
},this);

//attach a mouse out callback to a particular area. If the mouse leaves disable drop
cmp.getView().scroller.on('mouseout',function(e,t,o) {
	if (cmp.dragging) {
		OWF.DragAndDrop.setDropEnabled(false);
	}
},this);
   */


/**
	Executes the callback passed when a drag starts in any widget.
	@name onDragStart
	@methodOf OWF.DragAndDrop

	@param {Function} callback The function to execute as a callback.
	@param {Object} scope The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.

	@example
//example callback, highlights an Ext Grid when a drag occurs
OWF.DragAndDrop.onDragStart(function(sender, msg) {
	//get the Ext Grid
	var grid = this.getComponent(this.gridId);

	//check custom dragDropGroup property to see if the drag is meant for this grid
	//if so highlight the grid by adding the ddOver class
	if (grid && msg != null && msg.dragDropGroup == 'users') {
		grid.getView().scroller.addClass('ddOver');
	}
}, this);
*/

/**
	Executes the callback passed when a drag stops in any widget.
	@name onDragStop
	@methodOf OWF.DragAndDrop

	@param {Function} callback The function to execute as a callback.
	@param {Object} scope The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.

	@example

OWF.DragAndDrop.onDragStop(function(sender, msg) {
	// do something here
}, this);
*/

/**
	Executes the callback passed when a drop occurs in the widget. If one has multiple dropZones in a widget it is easier to use <a href="#addDropZoneHandler">addDropZoneHandler</a>
	@name onDrop
	@methodOf OWF.DragAndDrop

	@param {Function} callback The function to execute as a callback.
	@param {Object} scope The scope (this reference) in which the function is executed. If omitted, defaults to the browser window.

	@example

OWF.DragAndDrop.onDrop(function(sender, msg) {
	var data = msg.dragDropData;

	// do something with the data here
}, this);
	*/

// --------------------------------------------------------------------------------------------------
// ------------------- Launcher ---------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------

/**
	Launches a Widget based on the config.
	@name launch
	@methodOf OWF.Launcher

	@param {Object} config object see example for structure
    @param {String} config.pane optional, valid values are 'sibling' or a pane guid. Value of 'sibling' launches the widget into the sibling pane if it exists. If a pane is not found, widget is launched in the same pane. See <a href="OWF.html#.getPanes">OWF.getPanes</a> to find out how to get panes.
    @param {String} config.universalName universalName or guid maybe identify the widget to be launched
    @param {String} config.guid widget definition guid of the widget to launch
    @param {String} config.title title to use for the widget
    @param {String} config.titleRegex optional regex used to replace the previous title with the new value of title
    @param {Boolean} config.launchOnlyIfClosed If true, Widget will only be launched if it is not already opened. If it is opened, then the widget will be restored.
    @param {String} config.data initial launch config data to be passed to a widget only if the widget is opened.
    @param {Function} callback a function to be called once after the launchWidget is executed
    @see <a href="Ozone.state.WidgetState.html#getWidgetState">getWidgetState</a> to see widget state object structure.

    @example
// launch widget in the same pane
OWF.Launcher.launch({
	universalName: 'universal name of widget to launch',
	guid: 'guid of widget to launch',
	title: 'title to replace the widgets title',
	titleRegex: 'regex',
	launchOnlyIfClosed: true,
	data: 'dataString'
});

// launch widget in following preference: empty pane, sibling, or same pane.
// this is done by sorting panes by no of widgets, and picking the pane with the lowest no of widgets.
OWF.getPanes(function (panes) {
    var pane;

    if(panes.length <= 2) {
        pane = 'sibling';
    }
    else {
        panes = Ext.Array.sort(panes, function (a, b) {
            if(a.widgets.length === b.widgets.length)
                return 0;
            else if(a.widgets.length < b.widgets.length)
                return -1;
            else if(a.widgets.length > b.widgets.length)
                return 1;
        });
        pane = panes[0].widgets.length === 0 ? panes[0].id : 'sibling'
    }

    OWF.Launcher.launch({
        pane: pane,
        universalName: 'universal name of widget to launch',
        guid: 'guid of widget to launch',
        title: 'title to replace the widgets title',
        titleRegex: 'regex',
        launchOnlyIfClosed: true,
        data: 'dataString'
    });
});
*/

/**
	Retrieves initial launch data for this widget if it is opened by another widget.  If launched via an intent, it will return the JSON string { intents: true }.
	@name getLaunchData
	@methodOf OWF.Launcher

	@returns {Object} data object which contains initial launch data for the widget

	@example
var launchData = OWF.Launcher.getLaunchData();
if (launchData != null) {
	var data = Ozone.util.parseJson(launchData);  //in this example the data object has two fields: channel and message
	if (data != null) {
		//do something with the data
		OWF.Eventing.subscribe(data.channel, function() {});
	}
}
*/

// --------------------------------------------------------------------------------------------------
// ------------------- Chrome -----------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------

/**
	Checks to see if the Widget Chrome has already been modified.  This is useful when the widget iframe is reloaded.
	@name isModified
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Function} cfg.callback The function which receives the results.
	This method will be passed an object which has following properties. <br>
	<br>
		{Boolean} success: true if the widget is currently opened on the dashboard, or else false. <br>
		{Boolean} modified: true if the widget chrome(header) is modified, or else false. <br>
	*
	@example
OWF.Chrome.isModified({
	callback: function(msg) {
		//msg will always be a json string
		var res = Ozone.util.parseJson(msg);
		if (res.success) {
			//if the chrome was never modified
			if (!res.modified) {
			   //do something, perhaps add buttons
			}
			//if we already modified the chrome
			else {
			  //do something or perhaps nothing if the buttons are already added
			}
		}
	}
});
*/


/**
	Adds buttons to the Widget Chrome. Buttons are added after existing buttons.
	@name addHeaderButtons
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Object[]} cfg.items an array of buttons configurations to add to the chrome.  See example for button configs
	@param {String} cfg.items[*].itemId itemId is a unique id among all buttons that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate buttons which may not be able to be removed properly.
	@param {String} cfg.items[*].xtype xtype is ExtJS-like property used to determine the component to create.  Currently the Widget Chrome API only supports two xtype values: ‘button’ and ‘widgettool’.  xtype is an optional field, if it is omitted ‘widgettool’ is used.
	@param {String} cfg.items[*].type Used only for ‘widgettool’ buttons.  It determines the standard icon to be used.  For a complete list of types please see the ExtJS 4.x API documentation, <a href='http://docs.sencha.com/ext-js/4-0/#/api/Ext.panel.Tool-cfg-type'>http://docs.sencha.com/ext-js/4-0/#/api/Ext.panel.Tool-cfg-type</a>
	@param {String} cfg.items[*].icon This property defines the URL of the image to be used for the button.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].text This property defines text to appear alongside the button.  This property is only used if the xtype is ‘button.’  ‘widgettool’ will not show text.
	@param {Object} cfg.items[*].tooltip This property defines a tooltip.  It has two important sub properties, title and text.  tooltip is only used when the xtype is ‘button’
	@param {Function} cfg.items[*].handler The handler attribute defines a function to be executed when the button is pressed. This function is executed using Widget Eventing API from inside the widget.  The internal channel name used is the itemId attribute. This function’s parameter list contains the standard parameters for an Eventing callback function.

	@example
OWF.Chrome.addHeaderButtons({
	items: [
		{
			xtype: 'button',
			//path to an image to use. this path should either be fully qualified or relative to the /owf context
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Alert',
			itemId:'alert',
			tooltip:  {
			  text: 'Alert!'
			},
			handler: function(sender, data) {
				//widgetState is an already instantiated WidgetState Obj
				if (widgetState) {
					widgetState.getWidgetState({
						callback: function(state) {
							//check if the widget is visible
							if (!state.collapsed && !state.minimized && state.active) {
								//only render visual content, perhaps popup a message box if the widget is visible
								//otherwise it may not render correctly
							}
						}
					});
				}
			}
		},
		{
			xtype: 'widgettool',
			//path to an image to use. this path should either be fully qualified or relative to the /owf context
			icon: './themes/common/images/skin/information.png',
			itemId:'help',
			handler: function(sender, data) {
				alert('About Button Pressed');
			}
		},
		{
			//gear is a standard ext tool type
			type: 'gear',
			itemId:'gear',
			handler: function(sender, data) {
				alert('Utility Button Pressed');
			}
		}
	]
});
   */

/**
	Updates any existing buttons in the Widget Chrome based on the itemId.
	@name updateHeaderButtons
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Object[]} cfg.items an array of buttons configurations to add to the chrome.  See example below for button configs
	@param {String} cfg.items[*].itemId itemId is a unique id among all buttons that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate buttons which may not be able to be removed properly.
	@param {String} cfg.items[*].xtype xtype is ExtJS-like property used to determine the component to create.  Currently the Widget Chrome API only supports two xtype values: ‘button’ and ‘widgettool’.  xtype is an optional field, if it is omitted ‘widgettool’ is used.
	@param {String} cfg.items[*].type Used only for ‘widgettool’ buttons.  It determines the standard icon to be used.  For a complete list of types please see the ExtJS 4.x API documentation, <a href='http://docs.sencha.com/ext-js/4-0/#/api/Ext.panel.Tool-cfg-type'>http://docs.sencha.com/ext-js/4-0/#/api/Ext.panel.Tool-cfg-type</a>
	@param {String} cfg.items[*].icon This property defines the URL of the image to be used for the button.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].text This property defines text to appear alongside the button.  This property is only used if the xtype is ‘button.’  ‘widgettool’ will not show text.
	@param {Object} cfg.items[*].tooltip This property defines a tooltip.  It has two important sub properties, title and text.  tooltip is only used when the xtype is ‘button’
	@param {Function} cfg.items[*].handler The handler attribute defines a function to be executed when the button is pressed. This function is executed using Widget Eventing API from inside the widget.  The internal channel name used is the itemId attribute. This function’s parameter list contains the standard parameters for an Eventing callback function.

	@example
OWF.Chrome.updateHeaderButtons({
	items: [
		{
			xtype: 'button',
			//path to an image to use. this path should either be fully qualified or relative to the /owf context
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Alert',
			itemId:'alert',
			tooltip:  {
			  text: 'Alert!'
			},
			handler: function(sender, data) {
				//widgetState is an already instantiated WidgetState Obj
				if (widgetState) {
					widgetState.getWidgetState({
						callback: function(state) {
							//check if the widget is visible
							if (!state.collapsed && !state.minimized && state.active) {
								//only render visual content, perhaps popup a message box if the widget is visible
								//otherwise it may not render correctly
							}
						}
					});
				}
			}
		},
		{
			xtype: 'widgettool',
			//path to an image to use. this path should either be fully qualified or relative to the /owf context
			icon: './themes/common/images/skin/information.png',
			itemId:'help',
			handler: function(sender, data) {
				alert('About Button Pressed');
			}
		},
		{
			//gear is a standard ext tool type
			type: 'gear',
			itemId:'gear',
			handler: function(sender, data) {
				alert('Utility Button Pressed');
			}
		}
	]
});
*/

/**
	Inserts new buttons to the Widget Chrome.  Buttons are added to the same area as existing buttons.
	@name insertHeaderButtons
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Number} [cfg.pos=0] 0-based index of where buttons will be added, among any pre-existing buttons.
	@param {Object[]} cfg.items an array of buttons configurations to insert to the chrome.  See example below for button configs
	@param {String} cfg.items[*].itemId itemId is a unique id among all buttons that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate buttons which may not be able to be removed properly.
	@param {String} cfg.items[*].xtype xtype is ExtJS-like property used to determine the component to create.  Currently the Widget Chrome API only supports two xtype values: ‘button’ and ‘widgettool’.  xtype is an optional field, if it is omitted ‘widgettool’ is used.
	@param {String} cfg.items[*].type Used only for ‘widgettool’ buttons.  It determines the standard icon to be used.  For a complete list of types please see the ExtJS 4.x API documentation, <a href='http://docs.sencha.com/ext-js/4-0/#/api/Ext.panel.Tool-cfg-type'>http://docs.sencha.com/ext-js/4-0/#/api/Ext.panel.Tool-cfg-type</a>
	@param {String} cfg.items[*].icon This property defines the URL of the image to be used for the button.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].text This property defines text to appear alongside the button.  This property is only used if the xtype is ‘button.’  ‘widgettool’ will not show text.
	@param {Object} cfg.items[*].tooltip This property defines a tooltip.  It has two important sub properties, title and text.  tooltip is only used when the xtype is ‘button’
	@param {Function} cfg.items[*].handler The handler attribute defines a function to be executed when the button is pressed. This function is executed using Widget Eventing API from inside the widget.  The internal channel name used is the itemId attribute. This function’s parameter list contains the standard parameters for an Eventing callback function.

	@example
OWF.Chrome.insertHeaderButtons({
	pos: 0,
	items: [
		{
			xtype: 'button',
			//path to an image to use. this path should either be fully qualified or relative to the /owf context
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Alert',
			itemId:'alert',
			tooltip:  {
				text: 'Alert!'
			},
			handler: function(sender, data) {
				//widgetState is an already instantiated WidgetState Obj
				if (widgetState) {
					widgetState.getWidgetState({
						callback: function(state) {
							//check if the widget is visible
							if (!state.collapsed && !state.minimized && state.active) {
								//only render visual content, perhaps popup a message box if the widget is visible
								//otherwise it may not render correctly
							}
						}
					});
				}
			}
		},
		{
			xtype: 'widgettool',
			//path to an image to use. this path should either be fully qualified or relative to the /owf context
			icon: './themes/common/images/skin/information.png',
			itemId:'help',
			handler: function(sender, data) {
				alert('About Button Pressed');
			}
		},
			{
			//gear is a standard ext tool type
			type: 'gear',
			itemId:'gear',
			handler: function(sender, data) {
				alert('Utility Button Pressed');
			}
		}
	]
});
*/

/**
	Removes existing buttons on the Widget Chrome based on itemId.
	@name removeHeaderButtons
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Object[]} cfg.items an array of buttons configurations to remove to the chrome.  Only itemId is required.
	See example below for button configs
	@param {String} cfg.items[*].itemId itemId is a unique id among all buttons that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate buttons which may not be able to be removed properly.

	@example
OWF.Chrome.removeHeaderButtons({
		items:[
			{
				itemId:'alert'
			},
			{
				itemId:'help'
			},
			{
				itemId:'gear'
			}
		]
});
*/

/**
	Lists all buttons that have been added to the widget chrome.
	@name listHeaderButtons
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Function} cfg.callback The function which receives the results.

	@example
OWF.Chrome.listHeaderButtons({
	callback: function(msg) {
		//msg will always be a json string
		var res = Ozone.util.parseJson(msg);
		if (res.success) {
			for (var i = 0; i < res.items.length; i++) {
				// do something with the buttons
			}
		}
	}
});
*/

/**
	Adds menus to the Widget Chrome.  Menus are added after existing menus.
	@name addHeaderMenus
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Object[]} cfg.items an array of menu configurations to add to the chrome.  See example for menu configs
	@param {String} cfg.items[*].parentId itemId is the itemId of the menu to which this configuration should be added as a sub-menu.  If omitted, the configuration will be added as a main menu on the menu toolbar.
	@param {String} cfg.items[*].itemId itemId is a unique id among all menus that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate menus which may not be able to be removed properly.
	@param {String} cfg.items[*].icon This property defines the URL of the image to be used for the menu.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].text This property defines text to appear alongside the menu.
	@param {Object} cfg.items[*].menu menu configuration object
	@param {Object[]} cfg.items[*].menu.items an array of menu item configurations to add to the chrome.  See example for menu item configs
	@param {String} cfg.items[*].menu.items[*].itemId itemId is a unique id among all menu items that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.
	@param {String} cfg.items[*].menu.items[*].xtype xtype is used to specify the type of menu item to add.  This attribute should be omitted unless specifying a menuseparator. Setting this value to "menuseparator" adds a separator bar to a menu, used to divide logical groups of menu items. If specified, only xtype should be specified.  Generally you will add one of these by using "-" in your items config rather than creating one directly using xtype.  See example below for usage.
	@param {String} cfg.items[*].menu.items[*].icon This property defines the URL of the image to be used for the menu item.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].menu.items[*].text This property defines text to appear for the menu item.
	@param {Function} cfg.items[*].menu.items[*].handler The handler attribute defines a function to be executed when the menu item is clicked. This function is executed using Widget Eventing API from inside the widget.  The internal channel name used is the itemId attribute. This function's parameter list contains the standard parameters for an Eventing callback function.
	@param {Object} cfg.items[*].menu.items[*].menu sub-menu configuration object.  See example for sub-menu config.

	@example
OWF.Chrome.addHeaderMenus({
	items: [
		{
			itemId:'regularMenu',
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Regular Menu',
			menu: {
				items: [
					{
						itemId:'regularMenuItem1',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Regular Menu Item 1',
						handler: function(sender, data) {
							alert('You clicked the Regular Menu menu item.');
						}
					}
				]
			}
		},
		{
			itemId:'snacks',
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Menu with Sub-Menu',
			menu: {
				items: [
					{
						itemId:'fruits',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Fruits',
						menu: {
							items: [
								{
									itemId:'apple',
									icon: './themes/common/images/skin/exclamation.png',
									text: 'Apple',
									handler: function(sender, data) {
										alert('Your snack will be an Apple.');
									}
								},
							   {
								   xtype: 'menuseparator'
							   },
								{
									itemId:'banana',
									icon: './themes/common/images/skin/exclamation.png',
									text: 'Banana',
									handler: function(sender, data) {
										alert('Your snack will be a Banana.');
									}
								}, {
									itemId:'cherry',
									icon: './themes/common/images/skin/exclamation.png',
									text: 'Cherries',
									handler: function(sender, data) {
										alert('Your snack will be Cherries.');
									}
								}
							]
						}
					},
					'-', // another way to add a menu separator
					{
						itemId:'cupcake',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Cupcake',
						handler: function(sender, data) {
							alert('Your snack will be a Cupcake.');
						}
					},
					{
						itemId:'chips',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Potato Chips',
						handler: function(sender, data) {
							alert('Your snack will be a Potato Chips.');
						}
					}
				]
			}
		}
	]
});
*/

/**
	Updates any existing menus in the Widget Chrome based on the itemId.
	@name updateHeaderMenus
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Object[]} cfg.items an array of menu configurations to add to the chrome.  See example for menu configs
	@param {String} cfg.items[*].itemId itemId is a unique id among all menus that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate menus which may not be able to be removed properly.
	@param {String} cfg.items[*].icon This property defines the URL of the image to be used for the menu.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].text This property defines text to appear alongside the menu.
	@param {Object} cfg.items[*].menu menu configuration object
	@param {Object[]} cfg.items[*].menu.items an array of menu item configurations to add to the chrome.  See example for menu item configs
	@param {String} cfg.items[*].menu.items[*].itemId itemId is a unique id among all menu items that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.
	@param {String} cfg.items[*].menu.items[*].xtype xtype is used to specify the type of menu item to add.  This attribute should be omitted unless specifying a menuseparator. Setting this value to "menuseparator" adds a separator bar to a menu, used to divide logical groups of menu items. If specified, only xtype should be specified.  See example below for usage.
	@param {String} cfg.items[*].menu.items[*].icon This property defines the URL of the image to be used for the menu item.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].menu.items[*].text This property defines text to appear for the menu item.
	@param {Function} cfg.items[*].menu.items[*].handler The handler attribute defines a function to be executed when the menu item is clicked. This function is executed using Widget Eventing API from inside the widget.  The internal channel name used is the itemId attribute. This function's parameter list contains the standard parameters for an Eventing callback function.
	@param {Object} cfg.items[*].menu.items[*].menu sub-menu configuration object.  See example for sub-menu config.

	@example
OWF.Chrome.updateHeaderMenus({
	items:[
		{
			itemId:'regularMenu',
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Regular Menu',
			menu: {
				items: [
					{
						itemId:'regularMenuItem1',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Regular Menu Item 1',
						handler: function(sender, data) {
							alert('You clicked the Regular Menu menu item.');
						}
					}
				]
			}
		},
		{
			itemId:'snacks',
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Menu with Sub-Menu',
			menu: {
				items: [
					{
						itemId:'fruits',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Fruits',
						menu: {
							items: [
								{
									itemId:'apple',
									icon: './themes/common/images/skin/exclamation.png',
									text: 'Apple',
									handler: function(sender, data) {
										alert('Your snack will be an Apple.');
									}
								},
							   {
								   xtype: 'menuseparator'
							   },
								{
									itemId:'banana',
									icon: './themes/common/images/skin/exclamation.png',
									text: 'Banana',
									handler: function(sender, data) {
										alert('Your snack will be a Banana.');
									}
								}, {
									itemId:'cherry',
									icon: './themes/common/images/skin/exclamation.png',
									text: 'Cherries',
									handler: function(sender, data) {
										alert('Your snack will be Cherries.');
									}
								}
							]
						}
					},
					'-', // another way to add a menu separator
					{
						itemId:'cupcake',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Cupcake',
						handler: function(sender, data) {
							alert('Your snack will be a Cupcake.');
						}
					},
					{
						itemId:'chips',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Potato Chips',
						handler: function(sender, data) {
							alert('Your snack will be a Potato Chips.');
						}
					}
				]
			}
		}
	]
});
*/

/**
	Inserts new menus into the Widget Chrome. Menus are added to the same area as existing menus.
	@name insertHeaderMenus
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Number} [cfg.pos=0] 0-based index of where menus will be added, among any pre-existing menus.
	@param {Object[]} cfg.items an array of menu configurations to add to the chrome.  See example for menu configs
	@param {String} cfg.items[*].parentId itemId is the itemId of the menu to which this configuration should be added as a sub-menu.  If omitted, the configuration will be added as a main menu on the menu toolbar.
	@param {String} cfg.items[*].itemId itemId is a unique id among all menus that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.  If itemId is not unique this may result in duplicate menus which may not be able to be removed properly.
	@param {String} cfg.items[*].icon This property defines the URL of the image to be used for the menu.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].text This property defines text to appear alongside the menu.  This property is only used if the xtype is ‘menu.’  ‘widgettool’ will not show text.
	@param {Object} cfg.items[*].menu menu configuration object
	@param {Object[]} cfg.items[*].menu.items an array of menu item configurations to add to the chrome.  See example for menu item configs
	@param {String} cfg.items[*].menu.items[*].itemId itemId is a unique id among all menu items that are added.  It is a required property.  It is used for identification and defines the internal Eventing channel which is used to execute the handler function.
	@param {String} cfg.items[*].menu.items[*].xtype xtype is used to specify the type of menu item to add.  This attribute should be omitted unless specifying a menuseparator. Setting this value to "menuseparator" adds a separator bar to a menu, used to divide logical groups of menu items. If specified, only xtype should be specified.  See example below for usage.
	@param {String} cfg.items[*].menu.items[*].icon This property defines the URL of the image to be used for the menu item.  If the URL is a relative path, it will be relative to the /owf context.  This is useful if the desired image is hosted by the OWF web server.  Otherwise a fully qualified URL should be used.  If type is being used to determine the image, the icon property is optional
	@param {String} cfg.items[*].menu.items[*].text This property defines text to appear for the menu item.
	@param {Function} cfg.items[*].menu.items[*].handler The handler attribute defines a function to be executed when the menu item is clicked. This function is executed using Widget Eventing API from inside the widget.  The internal channel name used is the itemId attribute. This function's parameter list contains the standard parameters for an Eventing callback function.
	@param {Object} cfg.items[*].menu.items[*].menu sub-menu configuration object.  See example for sub-menu config.

	@example
OWF.Chrome.insertHeaderMenus({
		pos: 0,
		items: [{
		 itemId:'insertedMenu',
			icon: './themes/common/images/skin/exclamation.png',
			text: 'Inserted Menu',
			menu: {
				items: [
					{
						itemId:'insertedMenuItem1',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Inserted Menu Item 1',
						handler: function(sender, data) {
							alert('You clicked the Inserted Menu menu item.');
						}
					},
					{
						xtype: 'menuseparator'
					},
					{
						itemId:'insertedMenuItem2',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Inserted Menu Item 2',
						handler: function(sender, data) {
							alert('You clicked the Inserted Menu menu item.');
						}
					},
					'-', // another way to add a menu separator
					{
						itemId:'insertedMenuItem3',
						icon: './themes/common/images/skin/exclamation.png',
						text: 'Inserted Menu Item 3',
						handler: function(sender, data) {
							alert('You clicked the Inserted Menu menu item.');
						}
					}
				]
			}
		}]
});
*/

/**
	Removes existing menus on the Widget Chrome based on itemId.
	@name removeHeaderMenus
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Object[]} cfg.items an array of objects containing itemIds for the menus to remove from the chrome.
	  See example below for button configs

	@example
OWF.Chrome.removeHeaderMenus({
	items: [{
		itemId: 'regularMenu'
	}]
});
*/

/**
	Lists all menus that have been added to the widget chrome.
	@name listHeaderMenus
	@methodOf OWF.Chrome

	@param {Object} cfg config object see below for properties
	@param {Function} cfg.callback The function which receives the results.

	@example
OWF.Chrome.listHeaderMenus({
	callback: function(msg) {
		//msg will always be a json string
		var res = Ozone.util.parseJson(msg);
		if (res.success) {
			for (var i = 0; i < res.items.length; i++) {
				// do something with the menus
			}
		}
	}
});
	*/

/**
  *
  *	@name getTitle
  * @methodOf OWF.Chrome
  * @description Gets the Widget's Title from the Chrome
  * @param {Object} cfg config object see below for properties
  * @param {Function} cfg.callback The function which receives the results.
  *
  * @example
  *    OWF.Chrome.getTitle({
  *     callback: function(msg) {
  *         //msg will always be a json string
  *         var res = Ozone.util.parseJson(msg);
  *         if (res.success) {
  *
  *           //do something with title
  *           // res.title
  *         }
  *     }
  *   });
  */

/**
  *	@name setTitle
  * @methodOf OWF.Chrome
  * @description Sets the Widget's Title in the Chrome
  * @param {Object} cfg config object see below for properties
  * @param {String} cfg.title The string which will replace the widget title
  * @param {Function} cfg.callback The function which receives the results.
  *
  * @example
  *    OWF.Chrome.setTitle({
  *     title: 'new title',
  *     callback: function(msg) {
  *         //msg will always be a json string
  *         var res = Ozone.util.parseJson(msg);
  *         if (res.success) {
  *           //get title back for confirmation
  *           // res.title
  *
  *         }
  *     }
  *   });
  */

// --------------------------------------------------------------------------------------------------
// ------------------- Preferences ------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------

/**
	Get the url for the Preference Server
	@name getUrl
	@methodOf OWF.Preferences

	@returns {String} url
 */

/**
	Sets the url for the Preference Server
	@name setUrl
	@methodOf OWF.Preferences

	@param {String} url
	@returns void
 */

/**
 * @name getDashboard
 * @methodOf OWF.Preferences
 * @description Gets the dashboard with the specified id
 * @param {Object} cfg config object see below for properties
 * @param {String} cfg.dashboardId Unigue dashbard identifier
 * @param {Function} cfg.onSuccess Callback function to capture the success result. Callback parameter is json representation of a dashboard.
 * This method will be passed the dashboard object which has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @example
 *
 * var onSuccess = function(dashboard) {
 *     alert(dashboard.name);
 * };
 *
 * var onFailure = function(error) {
     *     alert(error);
 * };
 *
 * Ozone.Preferences.getDashboard({
 *     dashboardId:'917b4cd0-ecbd-410b-afd9-42d150c26426',
 *     onSuccess:onSuccess,
 *     onFailure:onFailure
 * });
 */


 /***
	* @name getDefaultDashboard
	* @methodOf OWF.Preferences
	* @description Gets the user's default dashboard
	* @param {Object} cfg config object see below for properties
	* @param {Function} cfg.onSuccess Callback function to capture the success result.
	* This method is passed an object having the following properties:<br>
	* <br>
	*     {Boolean} success: true if dashboards found<br>
	*     {Number} results: number of dashboards found<br>
	*     {Array} data: array of dashboards objects found.  Dashboard object has the following properties:<br>
	*     <br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Boolean} alteredByAdmin: true if altered by an administrator<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Date} createdDate: date dashboard was created<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Boolean} isdefault: true if this is a default dashboard<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{String} name: name of dashboard<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Object} user: the dashoard owner.  Has the following properties:<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Object} createdBy: dashboard creator.  Has the following properties:<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Date} editedDate: date dashboard was last edited<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{Array} groups:  groups dashboard is assigned to<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{String} description: description of dashboard<br>
	*     &nbsp;&nbsp;&nbsp;&nbsp;{String} guid: uniqued dashboard identifier<br>
	*     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
	*     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
	*     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
	*     Panes can have the following parameters:<br>
	*     <ul style="list-style-type:none">
	*        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
	*        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
	*        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
	*        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
	*        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
	*        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
	*        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
	*        <ul style="list-style-type:none">
	*           <li>{String} type: vbox|hbox</li>
	*           <li>{String} align: stretch</li>
	*        </ul>
	*        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
	*        <ul style="list-style-type:none">
	*           <li>{String} widgetGuid: unique widget identifier</li>
	*           <li>{Number} width: width of widget in pixels</li>
	*           <li>{Number} zIndex: in pixels</li>
	*           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
	*           <li>{Boolean} pinned: true if widget is pinned open</li>
	*           <li>{String} buttonId: identifier of button that opens widget</li>
	*           <li>{Number} height: height of widget in pixels</li>
	*           <li>{Number} columnPos: position of widget in a column</li>
	*           <li>{String} name: widget name</li>
	*           <li>{Number} statePosition</li>
	*           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
	*           <li>{String} uniqueId: unique widget identifier on dashboard</li>
	*           <li>{Boolean} minimized: true if widget is minimized</li>
	*           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
	*           <li>{Boolean} collapsed: true if widget is collapsed</li>
	*           <li>{Number} y: y-axis position in pixels</li>
	*           <li>{Number} x: x-axis position in pixels</li>
	*           <li>{Boolean} maximized: true if widget is maximized</li>
	*        </ul>
	*        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
	*     </ul>
	*     <br>
	* <br>
	* @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
   * @example
   *
   * var onSuccess = function(cfg) {
   *         alert(cfg.data[0].name);
   * };
   *
   * var onFailure = function(error) {
       *     alert(error);
   * };
   *
   * Ozone.Preferences.getDefaultDashboard({
   *     onSuccess:onSuccess,
   *     onFailure:onFailure
   * });
   */
/**
 * @name setDefaultDashboard
 * @methodOf OWF.Preferences
 * @description Sets the user's default dashboard
 * @param {Object} cfg config object see below for properties
 * @param {String} cfg.dashboardId Unigue dashbard identifier
 * @param {Boolean} cfg.isDefault true to set as default dashboard
 * @param {Function} cfg.onSuccess Callback function to capture the success result. Callback parameter is json representation of a Dashboard.
 * This method will be passed the dashboard object which has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @example
 *
 * var onSuccess = function(dashboard) {
 *     alert(dashboard.name);
 * };
 *
 * var onFailure = function(error) {
 *     alert(error);
 * };
 *
 * OWF.Preferences.setDefaultDashboard({
 *     dashboardId:'917b4cd0-ecbd-410b-afd9-42d150c26426',
 *     isDefault:true,
 *     onSuccess:onSuccess,
 *     onFailure:onFailure
 * });
 */

/**
 * @name createOrUpdateDashboard
 * @methodOf OWF.Preferences
 * @description Saves changes to a new or existing dashboard
 * @param {Object} cfg config object see below for properties
 * @param {Object} cfg.json The encoded JSON object representing the dashboard.
 * The dashboard object has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {String} layout: layout of dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Number} columnCount: number of columns if dashboard is a portal type<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {List} EDashboardLayoutList: list of dashboard types<br>
 *     {String} defaultSettings: JSON string of default settings which varies by dashboard type<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Boolean} cfg.saveAsNew A Boolean indicating whether the entity being saved is new.
 * @param {Function} cfg.onSuccess Callback function to capture the success result. Callback parameter is json representation of a Dashboard.
 * This method will be passed the dashboard object which has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @param {Boolean} [cfg.async] Async true or false defaults to true
 * @example
 *
 * var onSuccess = function(dashboard) {
 *   alert(dashboard.name);
 * };
 *
 * var onFailure = function(error) {
 *   alert(error);
 * };
 *
 * var dashboard = {
 *   alteredByAdmin: 'false',
 *   createdDate: '04/18/2012 11:29 AM EDT',
 *   isGroupDashboard: false,
 *   isdefault: false,
 *   locked: false,
 *   name: 'My Dashboard',
 *   user: {
 *     userId: 'testAdmin1',
 *   },
 *   createdBy: {
 *     userId: 'testAdmin1',
 *     userRealName: 'Test Admin 1'
 *   },
 *   editedDate: '04/18/2012 11:29 AM EDT',
 *   groups: [],
 *   description: 'This is my dashboard',
 *   guid: guid.util.guid(),
 *   layoutConfig: {
 *       xtype: "desktoppane",
 *       flex: 1,
 *       height: "100%",
 *       items: [
 *       ],
 *       paneType: "desktoppane",
 *       widgets: [{
 *               widgetGuid: "ec5435cf-4021-4f2a-ba69-dde451d12551",
 *               uniqueId: guid.util.guid(),
 *               dashboardGuid: "6d7219cb-b485-ace5-946b-0affa1f227a3",
 *               paneGuid: guid.util.guid(),
 *               name: "Channel Listener",
 *               active: false,
 *               x: 50,
 *               y: 66,
 *               minimized: false,
 *               maximized: false,
 *               pinned: false,
 *               collapsed: false,
 *               columnPos: 0,
 *               buttonId: null,
 *               buttonOpened: false,
 *               region: "none",
 *               statePosition: 1,
 *               intentConfig: null,
 *               singleton: false,
 *               floatingWidget: false,
 *               background: false,
 *               zIndex: 19050,
 *               height: 440,
 *               width: 540
 *           }
 *       ],
 *       defaultSettings: {
 *           widgetStates: {
 *               "ec5435cf-4021-4f2a-ba69-dde451d12551": {
 *                   x: 50,
 *                   y: 66,
 *                   height: 440,
 *                   width: 540,
 *                   timestamp: 1349809747336
 *                }
 *           }
 *       }
 *      }
 * };
 *
 * OWF.Preferences.createOrUpdateDashboard({
 *   json: dashboard,
 *   saveAsNew: true,
 *   onSuccess: onSuccess,
 *   onFailure: onFailure,
 *   async: true
 * });
 */

/**
 * @name cloneDashboard
 * @methodOf OWF.Preferences
 * @description Copies an existing dashboard and saves it as new
 * @param {Object} cfg config object see below for properties
 * @param {Object} cfg.json The encoded JSON object representing the dashboard.
 * The dashboard object has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Function} cfg.onSuccess Callback function to capture the success result. Callback parameter is json representation of a Dashboard.
 * This method will be passed the dashboard object which has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @example
 *
 * var onSuccess = function(dashboard) {
 *   alert(dashboard.name);
 * };
 *
 * var onFailure = function(error) {
 *   alert(error);
 * };
 *
 * var dashboard = {
 *   alteredByAdmin: 'false',
 *   createdDate: '04/18/2012 11:29 AM EDT',
 *   isGroupDashboard: false,
 *   isdefault: false,
 *   name: 'My Dashboard',
 *   user: {
 *     userId: 'testAdmin1',
 *   },
 *   createdBy: {
 *     userId: 'testAdmin1',
 *     userRealName: 'Test Admin 1'
 *   },
 *   editedDate: '04/18/2012 11:29 AM EDT',
 *   groups: [],
 *   description: 'This is my dashboard',
 *   guid: guid.util.guid(),
 * };
 *
 * OWF.Preferences.cloneDashboard({
 *   json: dashboard,
 *   onSuccess: onSuccess,
 *   onFailure: onFailure
 * });
 */


/**
	@description Saves changes to existing dashboards
	@name updateAndDeleteDashboards
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {Array} cfg.viewsToUpdate array of JSON objects containing the view guid and data to be updated
	@param {Array} cfg.viewGuidsToDelete array of guids of views to be deleted
	@param {Boolean} cfg.updateOrder flag to update order
	@param {Function} cfg.onSuccess callback function to capture the success result
	@param {Function} [cfg.onFailure] callback to execute if there is an error (optional, a default alert provided)
 */

/**
 * @name deleteDashboard
 * @methodOf OWF.Preferences
 * @description Deletes the dashboard with the specified id
 * @param {Object} cfg config object see below for properties
 * @param {String} cfg.dashboardId Unigue dashbard identifier
 * @param {Function} cfg.onSuccess Callback function to capture the success result. Callback parameter is json representation of a Dashboard.
 * This method will be passed the dashboard object which has the following properties:<br>
 * <br>
 *     {Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     {Date} createdDate: date dashboard was created<br>
 *     {Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     {Boolean} isdefault: true if this is a default dashboard<br>
 *     {String} name: name of dashboard<br>
 *     {Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     {Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     {Date} editedDate: date dashboard was last edited<br>
 *     {Array} groups:  groups dashboard is assigned to<br>
 *     {String} description: description of dashboard<br>
 *     {String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @example
 *
 * var onSuccess = function(dashboard) {
 *     alert(dashboard.name);
 * };
 *
 * var onFailure = function(error) {
     *     alert(error);
 * };
 *
 * OWF.Preferences.deleteDashboard({
 *     dashboardId:'917b4cd0-ecbd-410b-afd9-42d150c26426',
 *     onSuccess:onSuccess,
 *     onFailure:onFailure
 * });
 */

/**
 * @name findDashboards
 * @methodOf OWF.Preferences
 * @description Returns all dashboards for the logged in user.
 * @param {Object} cfg config object see below for properties
 * @param {Function} cfg.onSuccess Callback function to capture the success result.
 * This method is passed an object having the following properties:<br>
 * <br>
 *     {Boolean} success: true if dashboards found<br>
 *     {Number} results: number of dashboards found<br>
 *     {Array} data: array of dashboards objects found.  Dashboard object has the following properties:<br>
 *     <br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Boolean} alteredByAdmin: true if altered by an administrator<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Date} createdDate: date dashboard was created<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Boolean} isGroupDashboard: true if dashboard is a group dashboard<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Boolean} isdefault: true if this is a default dashboard<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} name: name of dashboard<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Object} user: the dashoard owner.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Object} createdBy: dashboard creator.  Has the following properties:<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{String} userId: unique user identifier<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: user's name<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Date} editedDate: date dashboard was last edited<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{Array} groups:  groups dashboard is assigned to<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} description: description of dashboard<br>
 *     &nbsp;&nbsp;&nbsp;&nbsp;{String} guid: uniqued dashboard identifier<br>
 *     {String} layoutConfig: Holds the various containers and panes on a dashboard and the widgets inside of the panes, including the widget states.
 *     This parameter provides an EXT JS style configuration used to layout the supported pane types in an OWF dashboard along. Each
 *     internal definition can hold nested panes in an items array, widgets in a widgets array, and default values for those widgets in a defaultValues array.
 *     Panes can have the following parameters:<br>
 *     <ul style="list-style-type:none">
 *        <li>{String} xtype: container|accordionpane|desktoppane|fitpane|portalpane|tabbedpane|dashboardsplitter</li>
 *        <li>{Number} flex: 1 if for a pane; 3 for a container<li>
 *        <li>{String} htmlText: in pixels (e.g., 300px) or percent (e.g., 100%) or "variable"; valid if nested in a horizontally/vertically split pane</li>
 *        <li>{String} cls: left|right if nested in a horizontally split pane; top|bottom if nested in a vertically split pane; vbox|hbox if xtype is container</li>
 *        <li>{Array} items: an array of 2 nested pane configurations along with a possible dashboardspliiter for vbox and hbox containers; empty otherwise</li>
 *        <li>{String} paneType: accordionpane|desktoppane|fitpane|portalpane|tabbedpane; valid if xtype is not container</li>
 *        <li>{Array} layout: valid only for container xtype.  Includes the following elements:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} type: vbox|hbox</li>
 *           <li>{String} align: stretch</li>
 *        </ul>
 *        <li>{Array} widgets: array of widget state objects.  Each has the following properties:</li>
 *        <ul style="list-style-type:none">
 *           <li>{String} widgetGuid: unique widget identifier</li>
 *           <li>{Number} width: width of widget in pixels</li>
 *           <li>{Number} zIndex: in pixels</li>
 *           <li>{String} region: containing region on dashboard.  Dashboard type specific.</li>
 *           <li>{Boolean} pinned: true if widget is pinned open</li>
 *           <li>{String} buttonId: identifier of button that opens widget</li>
 *           <li>{Number} height: height of widget in pixels</li>
 *           <li>{Number} columnPos: position of widget in a column</li>
 *           <li>{String} name: widget name</li>
 *           <li>{Number} statePosition</li>
 *           <li>{Boolean} active: true if this widget is the active (has focus) widget</li>
 *           <li>{String} uniqueId: unique widget identifier on dashboard</li>
 *           <li>{Boolean} minimized: true if widget is minimized</li>
 *           <li>{Boolean} buttonOpened: true if button launched widget is opened</li>
 *           <li>{Boolean} collapsed: true if widget is collapsed</li>
 *           <li>{Number} y: y-axis position in pixels</li>
 *           <li>{Number} x: x-axis position in pixels</li>
 *           <li>{Boolean} maximized: true if widget is maximized</li>
 *        </ul>
 *        <li>{String} defaultSettings: JSON string of default settings which varies by pane type; not valid for containers</li>
 *     </ul>
 *     <br>
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @example
 *
 * var onSuccess = function(obj) {
 *     alert(obj.results);
 *     if (obj.results > 0) {
 *         for (var i = 0; i < obj.results; i++) {
 *             alert(obj.data[i].name);
 *         }
 *     }
 * };
 *
 * var onFailure = function(error) {
 *     alert(error);
 * };
 *
 * OWF.Preferences.findDashboards({
 *     onSuccess:onSuccess,
 *     onFailure:onFailure
 * });
 */

/**
 * @name findDashboardsByType
 * @methodOf OWF.Preferences
 * @deprecated Deprecated starting with OWF 7. Dashboards no longer have a specific type. This function is stubbed
 * to return success with 0 results until removal.
 * @description Returns all dashboards for the logged in user filtered by the type of dashboard.
 * @param {Object} cfg config object see below for properties
 * @param {String} cfg.type A string representing the type of dashboard. If using built in dashboard types, this would include desktop, tabbed, portal, and accordion.
 * @param {Function} cfg.onSuccess Callback function to capture the success result.
 * This method is passed an object having the following properties:<br>
 * <br>
 *     {Boolean} success: true if dashboards found<br>
 *     {Number} results: number of dashboards found<br>
 *     {Array} data: an empty array<br>
 *
 * <br>
 * @param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.
 * @example
 *
 * var onSuccess = function(obj) {
 *     alert(obj.results);
 *     if (obj.results > 0) {
 *         for (var i = 0; i < obj.results; i++) {
 *             alert(obj.data[i].name);
 *         }
 *     }
 * };
 *
 * var onFailure = function(error) {
 *     alert(error);
 * };
 *
 * OWF.Preferences.findDashboardsByType({
 *     type:'desktop',
 *     onSuccess:onSuccess,
 *     onFailure:onFailure
 * });
 */

/**
	@description Gets the widget with the specified id
	@name getWidget
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {String} cfg.widgetId The unique identifier (normally a guid) for the widget.
	@param {Function} cfg.onSuccess Callback function to capture the success result. Callback is passed the following object as a parameter: {id:Number, namespace:String, value:Object, path:String}
	This method is passed an object having the following properties:<br>
	<br>
		{Number} id: database pk identifier<br>
		{String} namespace: "widget"<br>
		{Object} value: widget object having the following properties:<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} editable: true if widget can be edited<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} visible: true if widget is visible<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} position<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} userId: widget owner identifier<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: widget owner name<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} namespace: widget name<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} url: url of widget application<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} headerIcon: url of widget header icon<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} image: url of widget image<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} smallIconUrl: url of widget's small icon<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} largeIconUrl: url of widget's large icon<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} width: width of the widget in pixels<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} height: height of the widget in pixels<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} x: x-axis position<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} y: y-axis position<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} minimized: true if widget is minimized<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} maximized: true if widget is maximized<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} widgetVersion: widget version<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} definitionVisible: true if definition is visible<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} singleton: true if widget is a singleton<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} background: true if widget runs in the background<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Array} allRequired: array of all widgets required by this widget<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Array} directRequired: array of all widgets directly required by this widget<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Array} widgetTypes: array of widget types this widget belongs to<br>
		<br>
		{String} path: unnique widget identifier<br>
	<br>
	@param {Function} [cfg.onFailure] Callback to execute if there is an error (optional, a default alert provided). Callback parameter is an error string.

	@example
var onSuccess = function(obj) {
	if (obj.value) {
		alert(obj.value.namespace);
	}
};

var onFailure = function(error) {
	alert(error);
};

OWF.Preferences.getWidget({
	widgetId:'ea5435cf-4021-4f2a-ba69-dde451d12551',
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	@description Gets all widgets for a given user.
	@name findWidgets
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {Boolean} [cfg.userOnly] boolean flag that determines whether to only return widgets assigned to the user (excluding widgets to which the user only has access via their assigned groups)
	@param {Object} [cfg.searchParams] object containing search parameters
	@param {String} [cfg.searchParams.widgetName] name of widget '%' are wildcards
	@param {String} [cfg.searchParams.widgetNameExactMatch] true or false to match the name exactly. defaults to false
	@param {String} [cfg.searchParams.widgetVersion] version of widget '%' are wildcards
	@param {String} [cfg.searchParams.widgetGuid] guid of widget '%' are wildcards
	@param {Function} cfg.onSuccess callback function to capture the success result.
	This method is passed an array of objects having the following properties:<br>
	<br>
		{Number} id: database pk identifier<br>
		{String} namespace: "widget"<br>
		{Object} value: widget object having the following properties:<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} editable: true if widget can be edited<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} visible: true if widget is visible<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} position<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} userId: widget owner identifier<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} userRealName: widget owner name<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} namespace: widget name<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} url: url of widget application<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} headerIcon: url of widget header icon<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} image: url of widget image<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} smallIconUrl: url of widget's small icon<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} largeIconUrl: url of widget's large icon<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} width: width of the widget in pixels<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} height: height of the widget in pixels<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} x: x-axis position<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Number} y: y-axis position<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} minimized: true if widget is minimized<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} maximized: true if widget is maximized<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{String} widgetVersion: widget version<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} definitionVisible: true if definition is visible<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} singleton: true if widget is a singleton<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Boolean} background: true if widget runs in the background<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Array} allRequired: array of all widgets required by this widget<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Array} directRequired: array of all widgets directly required by this widget<br>
		&nbsp;&nbsp;&nbsp;&nbsp;{Array} widgetTypes: array of widget types this widget belongs to<br>
		<br>
		{String} path: unnique widget identifier<br>
	<br>
	@param {Function} [cfg.onFailure] callback to execute if there is an error (optional, a default alert provided).  This callback is called with two parameters: a error message string, and optionally a status code

	@example
var onSuccess = function(widgets) {
	if (widgets.length > 0) {
		alert(widgets[0].value.namespace);
	}
};

var onFailure = function(error, status) {
	alert(error);
};

OWF.Preferences.findWidgets({
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	@description Saves changes to existing widgets
	@name updateAndDeleteWidgets
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {Array} cfg.widgetsToUpdate array of JSON objects containing the widget guid and data to be updated
	@param {Array} cfg.widgetGuidsToDelete array of guids of widgets to be deleted
	@param {Boolean} cfg.updateOrder flag to update order
	@param {Function} cfg.onSuccess callback function to capture the success result
	@param {Function} [cfg.onFailure] callback to execute if there is an error (optional, a default alert provided)
 */

/**
	@description Retrieves the user preference for the provided name and namespace
	@name getUserPreference
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {String} cfg.namespace The namespace of the requested user preference
	@param {String} cfg.name The name of the requested user preference
	@param {Function} cfg.onSuccess The function to be called if the user preference is successfully retrieved from
	the database.  This function takes a single argument, which is a JSON object.  If a preference is found, the
	complete JSON structure as shown below will be returned.  If it is not found this function be passed an empty JSON object.
	@example
The following is an example of a complete preference object passed to the onSuccess
function:
{
	"value":"true",
	"path":"militaryTime",
	"user":
	{
		"userId":"testAdmin1"
	},
	"namespace":"com.mycompany.AnnouncingClock"
}
		@param {Function} [cfg.onFailure] This parameter is optional. If this function is not specified a default error
		message will be displayed.This function is called if an error occurs on preference retrieval.  It is not
		called if the preference is simply missing.
		This function should accept two arguments:<br>
		<br>
		error: String<br>
		The error message<br>
		<br>
		Status: The numeric HTTP Status code (if applicable)<br>
		401: You are not authorized to access this entity.<br>
		500: An unexpected error occurred.<br>
		404: The user preference was not found.<br>
		400: The requested entity failed to pass validation.<br>

		@example
The following shows how to make a call to getUserPreference:
function onSuccess(pref){
	alert(Ozone.util.toString(pref.value));
}

function onFailure(error,status){
	alert('Error ' + error);
	alert(status);
}

// The following code calls getUserPreference with the above defined onSuccess and
// onFailure callbacks.
OWF.Preferences.getUserPreference({
	namespace:'com.company.widget',
	name:'First President',
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	@description Checks for the existence of a user preference for a given namespace and name
	@name doesUserPreferenceExist
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {String} cfg.namespace The namespace of the requested user
	@param {String} cfg.name The name of the requested user
	@param {Function} cfg.onSuccess The callback function that is called if a preference successfully return from the database.
	This method is passed an object having the following properties:<br>
	<br>
		{Number} statusCode: status code<br>
		{Boolean} preferenceExist: true if preference exists<br>
	<br>
    @param {Function} [cfg.onFailure] The callback function that is called if there was
    an error looking up the preference.  This function is <em>not</em> called
    if the preference simply does not exist

	@example
var onSuccess = function(obj) {
	if (obj.statusCode = 200) {
		alert(obj.preferenceExist);
	}
};

var onFailure = function(error) {
	alert(error);
};

OWF.Preferences.doesUserPreferenceExist({
	namespace:'foo.bar.0',
	name:'test path entry 0',
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	@description retrieves the current user logged into the system
	@name getCurrentUser
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {Function} cfg.onSuccess The callback function that is called for a successful retrieval of the user logged in.
	This method is passed an object having the following properties:<br>
	<br>
		{String} currentUserName: user name<br>
		{String} currentUser: user real name<br>
		{Date} currentUserPrevLogin: previous login date<br>
		{Number} currentId: database pk index<br>
	<br>
	@param {Function} cfg.[onFailure] The callback function that is called when the system is unable to retrieve the current user logged in. Callback parameter is an error string.

	@example
var onSuccess = function(obj) {
	if (obj) {
		alert(obj.currentUser);
	}
};

var onFailure = function(error) {
	alert(error);
};

OWF.Preferences.getCurrentUser({
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	@description For retrieving the OWF system server version
	@name getServerVersion
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {Function} cfg.onSuccess The callback function that is called for successfully retrieving the server version of the OWF system.
	This method is passed an object having the following properties:<br>
	<br>
		{String} {serverVersion: server version<br>
	<br>
	@param {Function} [cfg.onFailure] The callback function that is called when the system fails to retrieve the server version of the OWF system. Callback parameter is an error string.
	@example

var onSuccess = function(obj) {
	if (obj) {
		alert(obj.serverVersion);
	}
};

var onFailure = function(error) {
	alert(error);
};

OWF.Preferences.getServerVersion({
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	@description Creates or updates a user preference for the provided namespace and name.
	@name setUserPreference
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {String} cfg.namespace  The namespace of the user preference
	@param {String} cfg.name The name of the user preference
	@param {String} cfg.value  The value of the user preference. The value can be any string including JSON.
	@param {Function} cfg.onSuccess The function to be called if the user preference is successfully updated in
	the database.

	@example
The following is an example of a complete preference object passed to the onSuccess function:
{
	"value":"true",
	"path":"militaryTime",
	"user": {
		"userId":"testAdmin1"
	},
	"namespace":"com.mycompany.AnnouncingClock"
}
		@param {Function} [cfg.onFailure] The function to be called if the user preference cannot be stored in the database.
		If this function is not specified a default error message will be displayed. This function is passed
		back the following parameters:<br>
		<br>
		error: String<br>
		The error message<br>
		<br>
		Status: The HTTP Status code<br>
		401: You are not authorized to access this entity.<br>
		500: An unexpected error occurred.<br>
		404: The requested entity was not found.<br>
		400: The requested entity failed to pass validation.<br>

		@example
function onSuccess(pref){
	alert(pref.value);
}

function onFailure(error,status){
	alert('Error ' + error);
	alert(status);
}

var text = 'George Washington';
OWF.Preferences.setUserPreference({
	namespace:'com.company.widget',
	name:'First President',
	value:text,
	onSuccess:onSuccess,
	onFailure:onFailure
});
*/

/**
	Deletes a user preference with the provided namespace and name.
	@name deleteUserPreference
	@methodOf OWF.Preferences

	@param {Object} cfg config object see below for properties
	@param {String} cfg.namespace The namespace of the user preference
	@param {String} cfg.name The name of the user preference
	@param {Function} cfg.onSuccess The function to be called if the user preference is successfully deleted from the database.
	@example
The following is an example of a complete preference object passed to the onSuccess
function:

{
	"value":"true",
	"path":"militaryTime",
	"user":
	{
		"userId":"testAdmin1"
	},
	"namespace":"com.mycompany.AnnouncingClock"
}
		@param {Function} [cfg.onFailure] The function to be called if the user preference cannot be deleted from the
		database or if the preference does not exist. If this function is not specified a default error message will be
		displayed. This function is passed back the following parameters: <br>
		<br>
		error: String <br>
		The error message <br>
		<br>
		Status: The HTTP Status code<br>
		<br>
		401: You are not authorized to access this entity.<br>
		500: An unexpected error occurred.<br>
		404: The user preference was not found.<br>
		400: The requested entity failed to pass validation. <br>
		<br>
		@example
function onSuccess(pref){
	alert(pref.value);
}

function onFailure(error,status){
	alert('Error ' + error);
	alert(status);
}

OWF.Preferences.deleteUserPreference({
	namespace:'com.company.widget',
	name:'First President',
	onSuccess:onSuccess,
	onFailure:onFailure
});
 */

/**
	This method informs a widget developer if their widget is running from the OWF or from a direct URL call.
	@name isRunningInOWF
	@methodOf OWF.Util

	@returns  boolean true if the widget is inside OWF, false otherwise.
 */

/**
 @name isInContainer
 @methodOf OWF.Util
 * @description This method informs a widget developer if their widget is running
 * in a Container, like OWF
 *
 * @returns  boolean true if the widget is inside a container, false otherwise.
 *
 */

/**
	Returns a globally unique identifier (guid).
	@name guid
	@methodOf OWF.Util

	@returns  boolean true if the widget is inside OWF, false otherwise.
 */

/**
	This method returns flash/flex dom element from dom.
	@name getFlashApp
	@methodOf OWF.Util

	@param {String} id id of the flex dom element

	@returns  flash/flex object from dom
 */

 /**
	Basic logging capability - meant to be called by other methods which transform or validate data.
	@name logMetric
	@methodOf OWF.Metrics
	@since OWF 3.8.0

	@param {String} userId
	@param {String} userName
	@param {String} metricSite Identifier, potentially URL, for source of metric - typically OWF instance
	@param {String} componentName
	@param {String} componentId
	@param {String} componentInstanceId
	@param {String} metricTypeId String describing metric - recommend package name construct
	@param {String} metricData Any additional data for metric - do any necessary validation appropriate to metricTypeId before sending through
 */

/**
 * @description Logs a set of metrics to the server all at once.  All
 * metrics passed into a call to this function will be logged in a single
 * HTTP request, instead of one request per metric
 * @name logBatchMetrics
 * @methodOf OWF.Metrics
 * @since OWF 6.0
 *
 * @param {Array} metrics
 * @param {String} metrics[*].userId
 * @param {String} metrics[*].userName
 * @param {Number} metrics[*].metricTime The time at which is metric was collected (in UNIX time)
 * @param {String} metrics[*].site Identifier, potentially URL, for source of metric - typically OWF instance
 * @param {String} metrics[*].component
 * @param {String} metrics[*].componentId
 * @param {String} metrics[*].instanceId
 * @param {String} metrics[*].metricTypeId String describing metric - recommend package name construct
 * @param {String} metrics[*].widgetData Any additional data for metric - do any necessary validation appropriate to metricTypeId before sending through
 * @param {String} metrics[*].userAgent Should be set to the user-agent string of the browser
 */

/**
	Log view of widget - see calls in dashboards.
	@name logWidgetRender
	@methodOf OWF.Metrics
	@since OWF 3.8.0

	@param {String} userId     - see Ozone.metrics.logMetric userId
	@param {String} userName   - see Ozone.metrics.logMetric userName
	@param {String} metricSite - see Ozone.metrics.logMetric metricSite
	@param {Object} widget
 */

/**
	Get a logger by name, if the logger has not already been created it will be created.
	@name getLogger
	@methodOf OWF.Log
	@since OWF 3.8.0
	@param {String} loggerName
 */

/**
	Enable/Disable logging for the OWF application.
	@name setEnabled
	@methodOf OWF.Log
	@since OWF 3.8.0
	@param {Boolean} enabled true will enable logging false will disable
 */

/**
	Get OWF's default logger
	@name getDefaultLogger
	@methodOf OWF.Log
	@since OWF 3.8.0
 */

/**
	Launch the log window pop-up, this will re-launch the window in the event it has been closed.
	@name launchPopupAppender
	@methodOf OWF.Log
	@since OWF 3.8.0
 */

/**
	Gets the language that is currently being used by OWF.
	@name getLanguage
	@methodOf OWF.Lang

	@returns {String} Returns the ISO 639-1 language code for the language that is currently being used by OWF.
 */
